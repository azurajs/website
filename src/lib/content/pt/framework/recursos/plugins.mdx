---
title: Plugins
description: Guia completo de plugins do AzuraJS - estenda sua aplica√ß√£o com recursos poderosos integrados
category: Recursos
icon: lucide:plug
order: 10
---

# Plugins üîå

O AzuraJS vem com um ecossistema completo de plugins contendo **17 plugins integrados** que adicionam funcionalidades poderosas √†s suas aplica√ß√µes sem precisar de depend√™ncias externas. Todos os plugins s√£o acess√≠veis atrav√©s do export `azurajs/plugins` e seguem uma API consistente e f√°cil de usar.

## Vis√£o Geral

Plugins no AzuraJS s√£o fun√ß√µes middleware que podem ser aplicadas globalmente ou em rotas espec√≠ficas. Eles s√£o projetados para ser:

- **Zero Depend√™ncias**: Constru√≠dos inteiramente com m√≥dulos nativos do Node.js
- **Type-Safe**: Suporte completo ao TypeScript com defini√ß√µes de tipo detalhadas
- **Compon√≠veis**: Combine m√∫ltiplos plugins para funcionalidades complexas
- **Perform√°ticos**: Otimizados para uso em produ√ß√£o
- **Extens√≠veis**: F√°cil de criar plugins personalizados

## Plugins Dispon√≠veis

### Plugins de Seguran√ßa

#### üõ°Ô∏è Helmet

Adiciona headers de seguran√ßa para proteger sua aplica√ß√£o de vulnerabilidades web comuns.

```typescript
import { AzuraClient } from "azurajs";
import { helmet } from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  frameguard: { action: 'deny' },
  noSniff: true,
  xssFilter: true,
  hidePoweredBy: true
}));
```

**Op√ß√µes:**
- `contentSecurityPolicy`: Configurar diretivas CSP
- `hsts`: Configura√ß√µes do HTTP Strict Transport Security
- `frameguard`: Configura√ß√£o do X-Frame-Options
- `noSniff`: Ativar X-Content-Type-Options: nosniff
- `xssFilter`: Ativar X-XSS-Protection
- `hidePoweredBy`: Remover header X-Powered-By
- `dnsPrefetchControl`: Controlar DNS prefetching
- `referrerPolicy`: Definir Referrer-Policy

#### üåê CORS

Habilite Cross-Origin Resource Sharing para sua API.

```typescript
import { cors } from "azurajs/plugins";

app.use(cors({
  origins: ["http://localhost:3000", "https://example.com"],
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: ["X-Total-Count"],
  credentials: true,
  maxAge: 3600
}));
```

**Op√ß√µes:**
- `origins`: Array de origens permitidas (use `["*"]` para todas)
- `methods`: M√©todos HTTP permitidos
- `allowedHeaders`: Headers de requisi√ß√£o permitidos
- `exposedHeaders`: Headers expostos ao navegador
- `credentials`: Permitir cookies e headers de autoriza√ß√£o
- `maxAge`: Dura√ß√£o do cache de preflight (segundos)

#### üîí CSRF

Proteja contra ataques de Cross-Site Request Forgery.

```typescript
import { csrf } from "azurajs/plugins";

app.use(csrf({
  secret: process.env.CSRF_SECRET,
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  },
  ignoreMethods: ['GET', 'HEAD', 'OPTIONS']
}));

// Use nas suas rotas
app.get('/form', (req, res) => {
  res.send(`
    <form method="POST" action="/submit">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button>Enviar</button>
    </form>
  `);
});
```

**Recursos:**
- Gera√ß√£o autom√°tica de tokens
- Armazenamento baseado em cookies ou sess√£o
- M√©todos ignorados configur√°veis
- Valida√ß√£o de token

#### üîê Autentica√ß√£o JWT

Sistema completo de autentica√ß√£o JWT com assinatura, verifica√ß√£o e middleware.

```typescript
import { jwtMiddleware, createJWT, verifyJWT } from "azurajs/plugins";

// Criar um token JWT
const token = createJWT(
  { userId: 123, role: 'admin' },
  { 
    secret: process.env.JWT_SECRET,
    expiresIn: 3600,      // 1 hora
    algorithm: 'HS256',
    issuer: 'myapp',
    audience: 'myapp-users'
  }
);

// Proteger rotas
app.use('/api/protegido', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true,
  algorithm: 'HS256',
  getToken: (req) => {
    const auth = req.headers.authorization;
    if (auth && auth.startsWith('Bearer ')) {
      return auth.substring(7);
    }
    return null;
  }
}));

// Acessar token decodificado
app.get('/api/protegido/perfil', (req, res) => {
  const user = req.user; // Payload do JWT
  res.json({ user });
});

// Verificar um token manualmente
try {
  const payload = verifyJWT(token, { 
    secret: process.env.JWT_SECRET 
  });
  console.log(payload);
} catch (error) {
  console.error('Token inv√°lido:', error.message);
}
```

**Recursos:**
- Suporta algoritmos HS256, HS384 e HS512
- Claims padr√£o JWT (exp, iat, nbf, iss, aud)
- Extra√ß√£o customizada de token
- Acesso type-safe ao payload
- Zero depend√™ncias externas

### Plugins de Performance

#### üóúÔ∏è Compress√£o

Comprima automaticamente respostas com gzip, deflate ou Brotli.

```typescript
import { compression } from "azurajs/plugins";

app.use(compression({
  threshold: 1024,      // Comprimir apenas respostas > 1KB
  level: 6,             // N√≠vel de compress√£o (0-9, padr√£o: 6)
  filter: (contentType) => {
    // Comprimir conte√∫do baseado em texto
    return /json|text|javascript|css|xml|svg/.test(contentType);
  }
}));
```

**Op√ß√µes:**
- `threshold`: Tamanho m√≠nimo da resposta para comprimir (bytes)
- `level`: N√≠vel de compress√£o (0-9, maior = melhor compress√£o mas mais lento)
- `filter`: Fun√ß√£o para determinar quais content types comprimir

**Benef√≠cios:**
- Reduz largura de banda em at√© 70%
- Negocia√ß√£o autom√°tica de encoding (aceita: gzip, deflate, br)
- Filtragem inteligente por content-type

#### üè∑Ô∏è ETag

Habilite cache HTTP com gera√ß√£o e valida√ß√£o de ETag.

```typescript
import { etag } from "azurajs/plugins";

app.use(etag({
  algorithm: 'sha1',  // Algoritmo de hash
  weak: true          // Usar ETags fracos (W/"...")
}));
```

**Recursos:**
- Gera√ß√£o autom√°tica de ETag
- Retorna 304 Not Modified quando apropriado
- Suporta ETags fortes e fracos
- Reduz transfer√™ncia de dados para recursos n√£o modificados

#### üóÇÔ∏è Arquivos Est√°ticos

Sirva arquivos est√°ticos com recursos de cache e seguran√ßa.

```typescript
import { serveStatic } from "azurajs/plugins";

app.use('/public', serveStatic('./public', {
  maxAge: 86400000,        // Cache de 1 dia
  index: 'index.html',     // Arquivo padr√£o
  dotfiles: 'ignore',      // Ignorar dotfiles
  etag: true,
  lastModified: true,
  extensions: ['html', 'htm']
}));
```

**Op√ß√µes:**
- `maxAge`: Dura√ß√£o do cache em milissegundos
- `index`: Arquivo √≠ndice padr√£o
- `dotfiles`: Como lidar com dotfiles ('allow', 'ignore', 'deny')
- `etag`: Habilitar gera√ß√£o de ETag
- `lastModified`: Enviar header Last-Modified
- `extensions`: Extens√µes de arquivo a tentar

### Plugins de Manipula√ß√£o de Dados

#### üì¶ Sess√£o

Gerencie sess√µes de usu√°rio com mem√≥ria ou store customizado.

```typescript
import { session } from "azurajs/plugins";

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId',
  cookie: {
    maxAge: 86400000,    // 24 horas
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  },
  rolling: true,         // Estender sess√£o na atividade
  resave: false,
  saveUninitialized: false
}));

// Usar sess√µes
app.post('/login', (req, res) => {
  req.session.userId = user.id;
  req.session.role = user.role;
  res.json({ success: true });
});

app.get('/perfil', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'N√£o autorizado' });
  }
  res.json({ 
    userId: req.session.userId,
    role: req.session.role 
  });
});

// Destruir sess√£o
app.post('/logout', (req, res) => {
  req.session.destroy();
  res.json({ success: true });
});
```

**Exemplo de Store Customizado:**

```typescript
// Implementa√ß√£o de store Redis
class RedisStore {
  constructor(private redis: RedisClient) {}

  async get(id: string) {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : null;
  }

  async set(id: string, data: any) {
    await this.redis.setex(`session:${id}`, 86400, JSON.stringify(data));
  }

  async destroy(id: string) {
    await this.redis.del(`session:${id}`);
  }
}

app.use(session({
  secret: process.env.SESSION_SECRET,
  store: new RedisStore(redisClient)
}));
```

#### üì§ Multipart

Lide com upload de arquivos com multipart/form-data.

```typescript
import { multipart } from "azurajs/plugins";

app.post('/upload', multipart({
  limits: { 
    fileSize: 10 * 1024 * 1024,  // 10MB
    files: 5                       // M√°ximo 5 arquivos
  },
  allowedTypes: ['image/jpeg', 'image/png', 'application/pdf'],
  uploadDir: './uploads'
}), (req, res) => {
  const files = req.files;
  const fields = req.fields;
  
  res.json({ 
    uploaded: files.length,
    files: files.map(f => ({
      name: f.originalFilename,
      size: f.size,
      type: f.mimetype
    })),
    fields 
  });
});
```

**Op√ß√µes:**
- `limits`: Limites de tamanho e contagem
- `allowedTypes`: Array de tipos MIME permitidos
- `uploadDir`: Diret√≥rio para salvar arquivos enviados
- `keepExtensions`: Manter extens√µes de arquivo originais

#### üìè Limite de Body

Limite o tamanho do body da requisi√ß√£o para prevenir abuso.

```typescript
import { bodyLimit } from "azurajs/plugins";

app.use(bodyLimit({
  limit: '10mb',  // String ou n√∫mero (bytes)
  onLimit: (req, res) => {
    res.status(413).json({ 
      error: 'Payload muito grande',
      maxSize: '10mb'
    });
  }
}));
```

### Plugins de Infraestrutura

#### ‚ö° Rate Limiting

Previna abuso de API com limita√ß√£o de taxa de requisi√ß√µes.

```typescript
import { rateLimit } from "azurajs/plugins";

app.use('/api', rateLimit({
  windowMs: 60000,         // 1 minuto
  max: 100,                // M√°ximo 100 requisi√ß√µes por janela
  message: 'Muitas requisi√ß√µes, tente novamente mais tarde',
  statusCode: 429,
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  keyGenerator: (req) => req.ip  // Usar IP como chave
}));
```

**Recursos:**
- Janelas de tempo configur√°veis
- Rastreamento por IP ou chave customizada
- Respostas de erro customizadas
- Op√ß√£o de pular requisi√ß√µes bem-sucedidas/falhadas

#### üîÑ Proxy

Proxy reverso para microservi√ßos e gateways de API.

```typescript
import { proxyPlugin } from "azurajs/plugins";

app.use('/api/users', proxyPlugin('http://users-service:4001', {
  pathRewrite: {
    '^/api/users': '/users'
  },
  headers: {
    'X-Custom-Header': 'AzuraJS-Proxy'
  },
  timeout: 5000,
  logLevel: 'info',
  onProxyReq: (proxyReq, req) => {
    proxyReq.setHeader('X-Real-IP', req.ip);
  },
  onProxyRes: (proxyRes, req, res) => {
    console.log(`Proxy: ${req.url} -> ${proxyRes.statusCode}`);
  }
}));
```

#### ‚ö° Circuit Breaker

Implemente padr√£o de toler√¢ncia a falhas para aplica√ß√µes resilientes.

```typescript
import { circuitBreaker, CircuitBreaker } from "azurajs/plugins";

// Como middleware
app.use('/api/externo', circuitBreaker({
  failureThreshold: 5,    // Abrir ap√≥s 5 falhas
  timeout: 60000,         // Resetar ap√≥s 1 minuto
  onOpen: () => {
    console.log('Circuito aberto - parando requisi√ß√µes');
  },
  onClose: () => {
    console.log('Circuito fechado - retomando requisi√ß√µes');
  }
}));

// Como classe utilit√°ria
const dbBreaker = new CircuitBreaker({
  failureThreshold: 3,
  timeout: 30000
});

app.get('/usuarios', async (req, res) => {
  try {
    const usuarios = await dbBreaker.execute(async () => {
      return await db.query('SELECT * FROM users');
    });
    res.json(usuarios);
  } catch (error) {
    if (error.message === 'Circuit breaker is open') {
      return res.status(503).json({ 
        error: 'Servi√ßo temporariamente indispon√≠vel' 
      });
    }
    throw error;
  }
});
```

**Estados:**
- **Fechado**: Opera√ß√£o normal, requisi√ß√µes passam
- **Aberto**: Muitas falhas, requisi√ß√µes s√£o bloqueadas
- **Semi-Aberto**: Testando se o servi√ßo recuperou

### Tempo Real e Monitoramento

#### üìä Server-Sent Events (SSE)

Habilite push em tempo real do servidor com SSE.

```typescript
import { SSEManager, createSSEHandler } from "azurajs/plugins";

const sse = new SSEManager();

// Endpoint SSE
app.get('/eventos', createSSEHandler(sse));

// Broadcast para todos os clientes
app.post('/notificar', (req, res) => {
  sse.broadcast({
    event: 'notificacao',
    data: { message: 'Ol√° a todos!' }
  });
  res.json({ enviado: true });
});

// Enviar para cliente espec√≠fico
app.post('/notificar/:clientId', (req, res) => {
  sse.send(req.params.clientId, {
    event: 'mensagem-privada',
    data: { message: 'S√≥ para voc√™' }
  });
  res.json({ enviado: true });
});

// M√©tricas em tempo real
setInterval(() => {
  sse.broadcast({
    event: 'metricas',
    data: {
      cpu: process.cpuUsage(),
      memoria: process.memoryUsage(),
      uptime: process.uptime()
    }
  });
}, 1000);
```

**Uso no cliente:**

```javascript
const eventSource = new EventSource('/eventos');

eventSource.addEventListener('notificacao', (event) => {
  const data = JSON.parse(event.data);
  console.log('Notifica√ß√£o:', data.message);
});

eventSource.addEventListener('metricas', (event) => {
  const data = JSON.parse(event.data);
  atualizarDashboard(data);
});
```

#### ü©∫ Health Check

Monitore a sa√∫de da aplica√ß√£o e depend√™ncias.

```typescript
import { healthCheck } from "azurajs/plugins";

app.use('/health', healthCheck({
  checks: {
    database: async () => {
      try {
        await db.ping();
        return { 
          status: 'healthy',
          latency: 5,
          connections: db.pool.totalCount
        };
      } catch (error) {
        return { 
          status: 'unhealthy',
          error: error.message 
        };
      }
    },
    redis: async () => {
      try {
        await redis.ping();
        return { status: 'healthy' };
      } catch (error) {
        return { status: 'unhealthy', error: error.message };
      }
    },
    apiExterna: async () => {
      const inicio = Date.now();
      try {
        await fetch('https://api.example.com/health');
        return { 
          status: 'healthy',
          tempoResposta: Date.now() - inicio
        };
      } catch (error) {
        return { status: 'unhealthy' };
      }
    }
  },
  timeout: 5000,  // 5 segundos de timeout para checks
  cache: 10000    // Cachear resultados por 10 segundos
}));
```

**Formato da resposta:**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-04T10:30:00.000Z",
  "uptime": 3600.5,
  "checks": {
    "database": {
      "status": "healthy",
      "latency": 5,
      "connections": 10
    },
    "redis": {
      "status": "healthy"
    },
    "apiExterna": {
      "status": "healthy",
      "tempoResposta": 150
    }
  }
}
```

#### üî¢ Request ID

Adicione identificadores √∫nicos √†s requisi√ß√µes para rastreamento.

```typescript
import { requestId } from "azurajs/plugins";

app.use(requestId({
  header: 'X-Request-ID',
  generator: () => crypto.randomUUID()
}));

app.use((req, res, next) => {
  console.log(`[${req.id}] ${req.method} ${req.url}`);
  res.set('X-Request-ID', req.id);
  next();
});
```

#### ‚è±Ô∏è Timeout

Previna requisi√ß√µes travadas com timeouts autom√°ticos.

```typescript
import { timeout } from "azurajs/plugins";

app.use(timeout({
  duration: 30000,  // 30 segundos
  onTimeout: (req, res) => {
    console.error(`Timeout de requisi√ß√£o: ${req.method} ${req.url}`);
    res.status(408).json({ 
      error: 'Timeout de requisi√ß√£o',
      message: 'O servidor n√£o recebeu uma requisi√ß√£o completa a tempo'
    });
  }
}));
```

## Composi√ß√£o de Plugins

Combine m√∫ltiplos plugins para funcionalidade poderosa:

### Configura√ß√£o Pronta para Produ√ß√£o

```typescript
import { AzuraClient } from "azurajs";
import { 
  helmet, 
  cors, 
  compression, 
  rateLimit, 
  requestId,
  timeout,
  bodyLimit,
  healthCheck
} from "azurajs/plugins";

const app = new AzuraClient();

// Camada de seguran√ßa
app.use(helmet());
app.use(cors({ 
  origins: [process.env.FRONTEND_URL],
  credentials: true 
}));
app.use(bodyLimit({ limit: '10mb' }));

// Camada de performance
app.use(compression({ threshold: 1024 }));
app.use(timeout({ duration: 30000 }));

// Camada de monitoramento
app.use(requestId());
app.use('/health', healthCheck({
  checks: {
    db: async () => ({ status: await db.isHealthy() ? 'healthy' : 'unhealthy' })
  }
}));

// Rate limiting
app.use('/api', rateLimit({
  windowMs: 60000,
  max: 100
}));

// Suas rotas...
app.get('/api/usuarios', (req, res) => {
  res.json({ usuarios: [] });
});

app.listen(3000);
```

### API de Autentica√ß√£o

```typescript
import { 
  helmet, 
  cors, 
  csrf,
  jwtMiddleware,
  createJWT,
  rateLimit,
  bodyLimit
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(cors({ origins: [process.env.FRONTEND_URL], credentials: true }));
app.use(bodyLimit({ limit: '1mb' }));

// Rate limit em endpoints de autentica√ß√£o
app.use('/auth', rateLimit({
  windowMs: 900000,  // 15 minutos
  max: 5             // 5 tentativas
}));

// Endpoint de login
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  const usuario = await validarCredenciais(email, password);
  if (!usuario) {
    return res.status(401).json({ error: 'Credenciais inv√°lidas' });
  }
  
  const token = createJWT(
    { userId: usuario.id, role: usuario.role },
    { 
      secret: process.env.JWT_SECRET,
      expiresIn: 3600  // 1 hora
    }
  );
  
  res.json({ token, usuario: { id: usuario.id, email: usuario.email } });
});

// Rotas protegidas
app.use('/api', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true
}));

app.get('/api/perfil', (req, res) => {
  res.json({ usuario: req.user });
});
```

### Servi√ßo de Upload de Arquivos

```typescript
import { 
  helmet,
  csrf,
  multipart,
  bodyLimit,
  jwtMiddleware
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(bodyLimit({ limit: '50mb' }));
app.use(csrf());

app.post('/upload',
  jwtMiddleware({ secret: process.env.JWT_SECRET }),
  multipart({
    limits: { 
      fileSize: 50 * 1024 * 1024,
      files: 10
    },
    allowedTypes: ['image/*', 'application/pdf', 'video/mp4']
  }),
  async (req, res) => {
    const files = req.files;
    
    // Processar e salvar arquivos
    const arquivosSalvos = await Promise.all(
      files.map(arquivo => salvarNoStorage(arquivo))
    );
    
    res.json({ 
      enviados: arquivosSalvos.length,
      arquivos: arquivosSalvos 
    });
  }
);
```

### Gateway de Microservi√ßos

```typescript
import { 
  helmet,
  cors,
  rateLimit,
  proxyPlugin,
  circuitBreaker,
  requestId,
  healthCheck
} from "azurajs/plugins";

const gateway = new AzuraClient();

gateway.use(helmet());
gateway.use(cors({ origins: ['*'] }));
gateway.use(requestId());
gateway.use(rateLimit({ max: 1000, windowMs: 60000 }));

// Health check para o gateway
gateway.use('/health', healthCheck({
  checks: {
    servicoUsuarios: async () => {
      try {
        await fetch('http://users-service:4001/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    },
    servicoPedidos: async () => {
      try {
        await fetch('http://orders-service:4002/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    }
  }
}));

// Proxy para servi√ßos com circuit breaker
gateway.use('/usuarios', 
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://users-service:4001', {
    pathRewrite: { '^/usuarios': '' }
  })
);

gateway.use('/pedidos',
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://orders-service:4002', {
    pathRewrite: { '^/pedidos': '' }
  })
);

gateway.listen(3000);
```

## Criando Plugins Customizados

Voc√™ pode criar seus pr√≥prios plugins seguindo o mesmo padr√£o:

```typescript
import type { RequestHandler } from "azurajs";

interface OpcoesPluginCustomizado {
  habilitado?: boolean;
  prefixo?: string;
}

export function pluginCustomizado(opcoes: OpcoesPluginCustomizado = {}): RequestHandler {
  const { habilitado = true, prefixo = 'custom' } = opcoes;
  
  return (req, res, next) => {
    if (!habilitado) {
      return next();
    }
    
    // L√≥gica do seu plugin
    req.customData = `${prefixo}-${Date.now()}`;
    
    res.on('finish', () => {
      // Limpeza ou logging
      console.log(`Requisi√ß√£o finalizada: ${req.customData}`);
    });
    
    next();
  };
}
```

**Plugin avan√ßado com opera√ß√µes ass√≠ncronas:**

```typescript
export function pluginAssincrono(opcoes: Opcoes): RequestHandler {
  return async (req, res, next) => {
    try {
      // Opera√ß√µes ass√≠ncronas
      const dados = await buscarAlgunsDados();
      req.pluginData = dados;
      next();
    } catch (error) {
      next(error);
    }
  };
}
```

## Melhores Pr√°ticas

### 1. A Ordem Importa

Aplique plugins na ordem correta para funcionalidade ideal:

```typescript
// ‚úÖ Ordem correta
app.use(helmet());           // 1. Seguran√ßa primeiro
app.use(cors());             // 2. CORS
app.use(bodyLimit());        // 3. Limites de parsing do body
app.use(compression());      // 4. Compress√£o
app.use(requestId());        // 5. Rastreamento de requisi√ß√£o
app.use('/api', rateLimit()); // 6. Rate limiting
// ... suas rotas
```

### 2. Configura√ß√£o Espec√≠fica do Ambiente

```typescript
const isProducao = process.env.NODE_ENV === 'production';

app.use(helmet({
  hsts: isProducao ? { maxAge: 31536000 } : false
}));

app.use(session({
  cookie: {
    secure: isProducao,
    sameSite: isProducao ? 'strict' : 'lax'
  }
}));
```

### 3. Ajuste de Performance

```typescript
// Comprimir apenas respostas grandes
app.use(compression({ 
  threshold: 2048  // M√≠nimo de 2KB
}));

// Cachear health checks
app.use('/health', healthCheck({
  checks: { /* ... */ },
  cache: 30000  // Cache por 30 segundos
}));

// Otimizar rate limiting para alto tr√°fego
app.use(rateLimit({
  windowMs: 1000,  // Janelas de 1 segundo
  max: 10,         // Janelas menores, mais verifica√ß√µes
}));
```

### 4. Tratamento de Erros

```typescript
import { circuitBreaker } from "azurajs/plugins";

app.use('/api/externo', circuitBreaker({
  failureThreshold: 5,
  timeout: 60000,
  onOpen: () => {
    // Alertar sistema de monitoramento
    servicoMonitoramento.alerta('Circuit breaker aberto');
  }
}));

// Handler de erro global
app.use((error, req, res, next) => {
  console.error(`[${req.id}] Erro:`, error);
  res.status(500).json({ 
    error: 'Erro interno do servidor',
    requestId: req.id 
  });
});
```

### 5. Checklist de Seguran√ßa

Para deploys de produ√ß√£o, certifique-se de ter:

- ‚úÖ Helmet para headers de seguran√ßa
- ‚úÖ CORS configurado corretamente
- ‚úÖ Rate limiting em todos os endpoints p√∫blicos
- ‚úÖ Limites de tamanho do body
- ‚úÖ Prote√ß√£o CSRF para opera√ß√µes que mudam estado
- ‚úÖ Autentica√ß√£o JWT ou sess√£o
- ‚úÖ Timeouts de requisi√ß√£o
- ‚úÖ Endpoint de health check

## Impacto na Performance

### Resultados de Benchmark

- **Compress√£o**: 60-70% de redu√ß√£o de largura de banda
- **ETag**: 90% de redu√ß√£o para recursos cacheados
- **Request ID**: &lt; 0.5ms overhead
- **JWT Middleware**: &lt; 2ms overhead
- **Rate Limit**: &lt; 1ms overhead (in-memory)

### Uso de Mem√≥ria

- **Session Store**: ~50 bytes por sess√£o
- **SSE Manager**: ~1KB por cliente conectado
- **Rate Limit**: ~100 bytes por IP rastreado
- **Circuit Breaker**: ~100 bytes por inst√¢ncia
