---
title: Plugins
description: Guia completo de plugins do AzuraJS - estenda sua aplicaÃ§Ã£o com recursos poderosos integrados
category: Recursos
icon: lucide:plug
order: 10
---

# Plugins ğŸ”Œ

O AzuraJS vem com um ecossistema completo de plugins contendo **17 plugins integrados** que adicionam funcionalidades poderosas Ã s suas aplicaÃ§Ãµes sem precisar de dependÃªncias externas. Todos os plugins sÃ£o acessÃ­veis atravÃ©s do export `azurajs/plugins` e seguem uma API consistente e fÃ¡cil de usar.

## VisÃ£o Geral

Plugins no AzuraJS sÃ£o funÃ§Ãµes middleware que podem ser aplicadas globalmente ou em rotas especÃ­ficas. Eles sÃ£o projetados para ser:

- **Zero DependÃªncias**: ConstruÃ­dos inteiramente com mÃ³dulos nativos do Node.js
- **Type-Safe**: Suporte completo ao TypeScript com definiÃ§Ãµes de tipo detalhadas
- **ComponÃ­veis**: Combine mÃºltiplos plugins para funcionalidades complexas
- **PerformÃ¡ticos**: Otimizados para uso em produÃ§Ã£o
- **ExtensÃ­veis**: FÃ¡cil de criar plugins personalizados

## Plugins DisponÃ­veis

### Plugins de SeguranÃ§a

#### ğŸ›¡ï¸ Helmet

Adiciona headers de seguranÃ§a para proteger sua aplicaÃ§Ã£o de vulnerabilidades web comuns.

```typescript
import { AzuraClient } from "azurajs";
import { helmet } from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  frameguard: { action: 'deny' },
  noSniff: true,
  xssFilter: true,
  hidePoweredBy: true
}));
```

**OpÃ§Ãµes:**
- `contentSecurityPolicy`: Configurar diretivas CSP
- `hsts`: ConfiguraÃ§Ãµes do HTTP Strict Transport Security
- `frameguard`: ConfiguraÃ§Ã£o do X-Frame-Options
- `noSniff`: Ativar X-Content-Type-Options: nosniff
- `xssFilter`: Ativar X-XSS-Protection
- `hidePoweredBy`: Remover header X-Powered-By
- `dnsPrefetchControl`: Controlar DNS prefetching
- `referrerPolicy`: Definir Referrer-Policy

#### ğŸŒ CORS

Habilite Cross-Origin Resource Sharing para sua API.

```typescript
import { cors } from "azurajs/plugins";

app.use(cors({
  origins: ["http://localhost:3000", "https://example.com"],
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: ["X-Total-Count"],
  credentials: true,
  maxAge: 3600
}));
```

**OpÃ§Ãµes:**
- `origins`: Array de origens permitidas (use `["*"]` para todas)
- `methods`: MÃ©todos HTTP permitidos
- `allowedHeaders`: Headers de requisiÃ§Ã£o permitidos
- `exposedHeaders`: Headers expostos ao navegador
- `credentials`: Permitir cookies e headers de autorizaÃ§Ã£o
- `maxAge`: DuraÃ§Ã£o do cache de preflight (segundos)

#### ğŸ”’ CSRF

Proteja contra ataques de Cross-Site Request Forgery.

```typescript
import { csrf } from "azurajs/plugins";

app.use(csrf({
  secret: process.env.CSRF_SECRET,
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  },
  ignoreMethods: ['GET', 'HEAD', 'OPTIONS']
}));

// Use nas suas rotas
app.get('/form', (req, res) => {
  res.send(`
    <form method="POST" action="/submit">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button>Enviar</button>
    </form>
  `);
});
```

**Recursos:**
- GeraÃ§Ã£o automÃ¡tica de tokens
- Armazenamento baseado em cookies ou sessÃ£o
- MÃ©todos ignorados configurÃ¡veis
- ValidaÃ§Ã£o de token

#### ğŸ” AutenticaÃ§Ã£o JWT

Sistema completo de autenticaÃ§Ã£o JWT com assinatura, verificaÃ§Ã£o e middleware.

```typescript
import { jwtMiddleware, createJWT, verifyJWT } from "azurajs/plugins";

// Criar um token JWT
const token = createJWT(
  { userId: 123, role: 'admin' },
  { 
    secret: process.env.JWT_SECRET,
    expiresIn: 3600,      // 1 hora
    algorithm: 'HS256',
    issuer: 'myapp',
    audience: 'myapp-users'
  }
);

// Proteger rotas
app.use('/api/protegido', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true,
  algorithm: 'HS256',
  getToken: (req) => {
    const auth = req.headers.authorization;
    if (auth && auth.startsWith('Bearer ')) {
      return auth.substring(7);
    }
    return null;
  }
}));

// Acessar token decodificado
app.get('/api/protegido/perfil', (req, res) => {
  const user = req.user; // Payload do JWT
  res.json({ user });
});

// Verificar um token manualmente
try {
  const payload = verifyJWT(token, { 
    secret: process.env.JWT_SECRET 
  });
  console.log(payload);
} catch (error) {
  console.error('Token invÃ¡lido:', error.message);
}
```

**Recursos:**
- Suporta algoritmos HS256, HS384 e HS512
- Claims padrÃ£o JWT (exp, iat, nbf, iss, aud)
- ExtraÃ§Ã£o customizada de token
- Acesso type-safe ao payload
- Zero dependÃªncias externas

### Plugins de Performance

#### ğŸ—œï¸ CompressÃ£o

Comprima automaticamente respostas com gzip, deflate ou Brotli.

```typescript
import { compression } from "azurajs/plugins";

app.use(compression({
  threshold: 1024,      // Comprimir apenas respostas > 1KB
  level: 6,             // NÃ­vel de compressÃ£o (0-9, padrÃ£o: 6)
  filter: (contentType) => {
    // Comprimir conteÃºdo baseado em texto
    return /json|text|javascript|css|xml|svg/.test(contentType);
  }
}));
```

**OpÃ§Ãµes:**
- `threshold`: Tamanho mÃ­nimo da resposta para comprimir (bytes)
- `level`: NÃ­vel de compressÃ£o (0-9, maior = melhor compressÃ£o mas mais lento)
- `filter`: FunÃ§Ã£o para determinar quais content types comprimir

**BenefÃ­cios:**
- Reduz largura de banda em atÃ© 70%
- NegociaÃ§Ã£o automÃ¡tica de encoding (aceita: gzip, deflate, br)
- Filtragem inteligente por content-type

#### ğŸ·ï¸ ETag

Habilite cache HTTP com geraÃ§Ã£o e validaÃ§Ã£o de ETag.

```typescript
import { etag } from "azurajs/plugins";

app.use(etag({
  algorithm: 'sha1',  // Algoritmo de hash
  weak: true          // Usar ETags fracos (W/"...")
}));
```

**Recursos:**
- GeraÃ§Ã£o automÃ¡tica de ETag
- Retorna 304 Not Modified quando apropriado
- Suporta ETags fortes e fracos
- Reduz transferÃªncia de dados para recursos nÃ£o modificados

#### ğŸ—‚ï¸ Arquivos EstÃ¡ticos

Sirva arquivos estÃ¡ticos com recursos de cache e seguranÃ§a.

```typescript
import { serveStatic } from "azurajs/plugins";

app.use('/public', serveStatic('./public', {
  maxAge: 86400000,        // Cache de 1 dia
  index: 'index.html',     // Arquivo padrÃ£o
  dotfiles: 'ignore',      // Ignorar dotfiles
  etag: true,
  lastModified: true,
  extensions: ['html', 'htm']
}));
```

**OpÃ§Ãµes:**
- `maxAge`: DuraÃ§Ã£o do cache em milissegundos
- `index`: Arquivo Ã­ndice padrÃ£o
- `dotfiles`: Como lidar com dotfiles ('allow', 'ignore', 'deny')
- `etag`: Habilitar geraÃ§Ã£o de ETag
- `lastModified`: Enviar header Last-Modified
- `extensions`: ExtensÃµes de arquivo a tentar

### Plugins de ManipulaÃ§Ã£o de Dados

#### ğŸ“¦ SessÃ£o

Gerencie sessÃµes de usuÃ¡rio com memÃ³ria ou store customizado.

```typescript
import { session } from "azurajs/plugins";

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId',
  cookie: {
    maxAge: 86400000,    // 24 horas
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  },
  rolling: true,         // Estender sessÃ£o na atividade
  resave: false,
  saveUninitialized: false
}));

// Usar sessÃµes
app.post('/login', (req, res) => {
  req.session.userId = user.id;
  req.session.role = user.role;
  res.json({ success: true });
});

app.get('/perfil', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'NÃ£o autorizado' });
  }
  res.json({ 
    userId: req.session.userId,
    role: req.session.role 
  });
});

// Destruir sessÃ£o
app.post('/logout', (req, res) => {
  req.session.destroy();
  res.json({ success: true });
});
```

**Exemplo de Store Customizado:**

```typescript
// ImplementaÃ§Ã£o de store Redis
class RedisStore {
  constructor(private redis: RedisClient) {}

  async get(id: string) {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : null;
  }

  async set(id: string, data: any) {
    await this.redis.setex(`session:${id}`, 86400, JSON.stringify(data));
  }

  async destroy(id: string) {
    await this.redis.del(`session:${id}`);
  }
}

app.use(session({
  secret: process.env.SESSION_SECRET,
  store: new RedisStore(redisClient)
}));
```

#### ğŸ“¤ Multipart

Lide com upload de arquivos com multipart/form-data.

```typescript
import { multipart } from "azurajs/plugins";

app.post('/upload', multipart({
  limits: { 
    fileSize: 10 * 1024 * 1024,  // 10MB
    files: 5                       // MÃ¡ximo 5 arquivos
  },
  allowedTypes: ['image/jpeg', 'image/png', 'application/pdf'],
  uploadDir: './uploads'
}), (req, res) => {
  const files = req.files;
  const fields = req.fields;
  
  res.json({ 
    uploaded: files.length,
    files: files.map(f => ({
      name: f.originalFilename,
      size: f.size,
      type: f.mimetype
    })),
    fields 
  });
});
```

**OpÃ§Ãµes:**
- `limits`: Limites de tamanho e contagem
- `allowedTypes`: Array de tipos MIME permitidos
- `uploadDir`: DiretÃ³rio para salvar arquivos enviados
- `keepExtensions`: Manter extensÃµes de arquivo originais

#### ğŸ“ Limite de Body

Limite o tamanho do body da requisiÃ§Ã£o para prevenir abuso.

```typescript
import { bodyLimit } from "azurajs/plugins";

app.use(bodyLimit({
  limit: '10mb',  // String ou nÃºmero (bytes)
  onLimit: (req, res) => {
    res.status(413).json({ 
      error: 'Payload muito grande',
      maxSize: '10mb'
    });
  }
}));
```

### Plugins de Infraestrutura

#### âš¡ Rate Limiting

Previna abuso de API com limitaÃ§Ã£o de taxa de requisiÃ§Ãµes.

```typescript
import { rateLimit } from "azurajs/plugins";

app.use('/api', rateLimit({
  windowMs: 60000,         // 1 minuto
  max: 100,                // MÃ¡ximo 100 requisiÃ§Ãµes por janela
  message: 'Muitas requisiÃ§Ãµes, tente novamente mais tarde',
  statusCode: 429,
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  keyGenerator: (req) => req.ip  // Usar IP como chave
}));
```

**Recursos:**
- Janelas de tempo configurÃ¡veis
- Rastreamento por IP ou chave customizada
- Respostas de erro customizadas
- OpÃ§Ã£o de pular requisiÃ§Ãµes bem-sucedidas/falhadas

#### ğŸ”„ Proxy

Proxy reverso para microserviÃ§os e gateways de API.

```typescript
import { proxyPlugin } from "azurajs/plugins";

app.use('/api/users', proxyPlugin('http://users-service:4001', {
  pathRewrite: {
    '^/api/users': '/users'
  },
  headers: {
    'X-Custom-Header': 'AzuraJS-Proxy'
  },
  timeout: 5000,
  logLevel: 'info',
  onProxyReq: (proxyReq, req) => {
    proxyReq.setHeader('X-Real-IP', req.ip);
  },
  onProxyRes: (proxyRes, req, res) => {
    console.log(`Proxy: ${req.url} -> ${proxyRes.statusCode}`);
  }
}));
```

#### âš¡ Circuit Breaker

Implemente padrÃ£o de tolerÃ¢ncia a falhas para aplicaÃ§Ãµes resilientes.

```typescript
import { circuitBreaker, CircuitBreaker } from "azurajs/plugins";

// Como middleware
app.use('/api/externo', circuitBreaker({
  failureThreshold: 5,    // Abrir apÃ³s 5 falhas
  timeout: 60000,         // Resetar apÃ³s 1 minuto
  onOpen: () => {
    console.log('Circuito aberto - parando requisiÃ§Ãµes');
  },
  onClose: () => {
    console.log('Circuito fechado - retomando requisiÃ§Ãµes');
  }
}));

// Como classe utilitÃ¡ria
const dbBreaker = new CircuitBreaker({
  failureThreshold: 3,
  timeout: 30000
});

app.get('/usuarios', async (req, res) => {
  try {
    const usuarios = await dbBreaker.execute(async () => {
      return await db.query('SELECT * FROM users');
    });
    res.json(usuarios);
  } catch (error) {
    if (error.message === 'Circuit breaker is open') {
      return res.status(503).json({ 
        error: 'ServiÃ§o temporariamente indisponÃ­vel' 
      });
    }
    throw error;
  }
});
```

**Estados:**
- **Fechado**: OperaÃ§Ã£o normal, requisiÃ§Ãµes passam
- **Aberto**: Muitas falhas, requisiÃ§Ãµes sÃ£o bloqueadas
- **Semi-Aberto**: Testando se o serviÃ§o recuperou

### Tempo Real e Monitoramento

#### ğŸ“Š Server-Sent Events (SSE)

Habilite push em tempo real do servidor com SSE.

```typescript
import { SSEManager, createSSEHandler } from "azurajs/plugins";

const sse = new SSEManager();

// Endpoint SSE
app.get('/eventos', createSSEHandler(sse));

// Broadcast para todos os clientes
app.post('/notificar', (req, res) => {
  sse.broadcast({
    event: 'notificacao',
    data: { message: 'OlÃ¡ a todos!' }
  });
  res.json({ enviado: true });
});

// Enviar para cliente especÃ­fico
app.post('/notificar/:clientId', (req, res) => {
  sse.send(req.params.clientId, {
    event: 'mensagem-privada',
    data: { message: 'SÃ³ para vocÃª' }
  });
  res.json({ enviado: true });
});

// MÃ©tricas em tempo real
setInterval(() => {
  sse.broadcast({
    event: 'metricas',
    data: {
      cpu: process.cpuUsage(),
      memoria: process.memoryUsage(),
      uptime: process.uptime()
    }
  });
}, 1000);
```

**Uso no cliente:**

```javascript
const eventSource = new EventSource('/eventos');

eventSource.addEventListener('notificacao', (event) => {
  const data = JSON.parse(event.data);
  console.log('NotificaÃ§Ã£o:', data.message);
});

eventSource.addEventListener('metricas', (event) => {
  const data = JSON.parse(event.data);
  atualizarDashboard(data);
});
```

#### ğŸ©º Health Check

Monitore a saÃºde da aplicaÃ§Ã£o e dependÃªncias.

```typescript
import { healthCheck } from "azurajs/plugins";

app.use('/health', healthCheck({
  checks: {
    database: async () => {
      try {
        await db.ping();
        return { 
          status: 'healthy',
          latency: 5,
          connections: db.pool.totalCount
        };
      } catch (error) {
        return { 
          status: 'unhealthy',
          error: error.message 
        };
      }
    },
    redis: async () => {
      try {
        await redis.ping();
        return { status: 'healthy' };
      } catch (error) {
        return { status: 'unhealthy', error: error.message };
      }
    },
    apiExterna: async () => {
      const inicio = Date.now();
      try {
        await fetch('https://api.example.com/health');
        return { 
          status: 'healthy',
          tempoResposta: Date.now() - inicio
        };
      } catch (error) {
        return { status: 'unhealthy' };
      }
    }
  },
  timeout: 5000,  // 5 segundos de timeout para checks
  cache: 10000    // Cachear resultados por 10 segundos
}));
```

**Formato da resposta:**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-04T10:30:00.000Z",
  "uptime": 3600.5,
  "checks": {
    "database": {
      "status": "healthy",
      "latency": 5,
      "connections": 10
    },
    "redis": {
      "status": "healthy"
    },
    "apiExterna": {
      "status": "healthy",
      "tempoResposta": 150
    }
  }
}
```

#### ğŸ”¢ Request ID

Adicione identificadores Ãºnicos Ã s requisiÃ§Ãµes para rastreamento.

```typescript
import { requestId } from "azurajs/plugins";

app.use(requestId({
  header: 'X-Request-ID',
  generator: () => crypto.randomUUID()
}));

app.use((req, res, next) => {
  console.log(`[${req.id}] ${req.method} ${req.url}`);
  res.set('X-Request-ID', req.id);
  next();
});
```

#### â±ï¸ Timeout

Previna requisiÃ§Ãµes travadas com timeouts automÃ¡ticos.

```typescript
import { timeout } from "azurajs/plugins";

app.use(timeout({
  duration: 30000,  // 30 segundos
  onTimeout: (req, res) => {
    console.error(`Timeout de requisiÃ§Ã£o: ${req.method} ${req.url}`);
    res.status(408).json({ 
      error: 'Timeout de requisiÃ§Ã£o',
      message: 'O servidor nÃ£o recebeu uma requisiÃ§Ã£o completa a tempo'
    });
  }
}));
```

## ComposiÃ§Ã£o de Plugins

Combine mÃºltiplos plugins para funcionalidade poderosa:

### ConfiguraÃ§Ã£o Pronta para ProduÃ§Ã£o

```typescript
import { AzuraClient } from "azurajs";
import { 
  helmet, 
  cors, 
  compression, 
  rateLimit, 
  requestId,
  timeout,
  bodyLimit,
  healthCheck
} from "azurajs/plugins";

const app = new AzuraClient();

// Camada de seguranÃ§a
app.use(helmet());
app.use(cors({ 
  origins: [process.env.FRONTEND_URL],
  credentials: true 
}));
app.use(bodyLimit({ limit: '10mb' }));

// Camada de performance
app.use(compression({ threshold: 1024 }));
app.use(timeout({ duration: 30000 }));

// Camada de monitoramento
app.use(requestId());
app.use('/health', healthCheck({
  checks: {
    db: async () => ({ status: await db.isHealthy() ? 'healthy' : 'unhealthy' })
  }
}));

// Rate limiting
app.use('/api', rateLimit({
  windowMs: 60000,
  max: 100
}));

// Suas rotas...
app.get('/api/usuarios', (req, res) => {
  res.json({ usuarios: [] });
});

app.listen(3000);
```

### API de AutenticaÃ§Ã£o

```typescript
import { 
  helmet, 
  cors, 
  csrf,
  jwtMiddleware,
  createJWT,
  rateLimit,
  bodyLimit
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(cors({ origins: [process.env.FRONTEND_URL], credentials: true }));
app.use(bodyLimit({ limit: '1mb' }));

// Rate limit em endpoints de autenticaÃ§Ã£o
app.use('/auth', rateLimit({
  windowMs: 900000,  // 15 minutos
  max: 5             // 5 tentativas
}));

// Endpoint de login
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  const usuario = await validarCredenciais(email, password);
  if (!usuario) {
    return res.status(401).json({ error: 'Credenciais invÃ¡lidas' });
  }
  
  const token = createJWT(
    { userId: usuario.id, role: usuario.role },
    { 
      secret: process.env.JWT_SECRET,
      expiresIn: 3600  // 1 hora
    }
  );
  
  res.json({ token, usuario: { id: usuario.id, email: usuario.email } });
});

// Rotas protegidas
app.use('/api', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true
}));

app.get('/api/perfil', (req, res) => {
  res.json({ usuario: req.user });
});
```

### ServiÃ§o de Upload de Arquivos

```typescript
import { 
  helmet,
  csrf,
  multipart,
  bodyLimit,
  jwtMiddleware
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(bodyLimit({ limit: '50mb' }));
app.use(csrf());

app.post('/upload',
  jwtMiddleware({ secret: process.env.JWT_SECRET }),
  multipart({
    limits: { 
      fileSize: 50 * 1024 * 1024,
      files: 10
    },
    allowedTypes: ['image/*', 'application/pdf', 'video/mp4']
  }),
  async (req, res) => {
    const files = req.files;
    
    // Processar e salvar arquivos
    const arquivosSalvos = await Promise.all(
      files.map(arquivo => salvarNoStorage(arquivo))
    );
    
    res.json({ 
      enviados: arquivosSalvos.length,
      arquivos: arquivosSalvos 
    });
  }
);
```

### Gateway de MicroserviÃ§os

```typescript
import { 
  helmet,
  cors,
  rateLimit,
  proxyPlugin,
  circuitBreaker,
  requestId,
  healthCheck
} from "azurajs/plugins";

const gateway = new AzuraClient();

gateway.use(helmet());
gateway.use(cors({ origins: ['*'] }));
gateway.use(requestId());
gateway.use(rateLimit({ max: 1000, windowMs: 60000 }));

// Health check para o gateway
gateway.use('/health', healthCheck({
  checks: {
    servicoUsuarios: async () => {
      try {
        await fetch('http://users-service:4001/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    },
    servicoPedidos: async () => {
      try {
        await fetch('http://orders-service:4002/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    }
  }
}));

// Proxy para serviÃ§os com circuit breaker
gateway.use('/usuarios', 
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://users-service:4001', {
    pathRewrite: { '^/usuarios': '' }
  })
);

gateway.use('/pedidos',
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://orders-service:4002', {
    pathRewrite: { '^/pedidos': '' }
  })
);

gateway.listen(3000);
```

## Criando Plugins Customizados

VocÃª pode criar seus prÃ³prios plugins seguindo o mesmo padrÃ£o:

```typescript
import type { RequestHandler } from "azurajs";

interface OpcoesPluginCustomizado {
  habilitado?: boolean;
  prefixo?: string;
}

export function pluginCustomizado(opcoes: OpcoesPluginCustomizado = {}): RequestHandler {
  const { habilitado = true, prefixo = 'custom' } = opcoes;
  
  return (req, res, next) => {
    if (!habilitado) {
      return next();
    }
    
    // LÃ³gica do seu plugin
    req.customData = `${prefixo}-${Date.now()}`;
    
    res.on('finish', () => {
      // Limpeza ou logging
      console.log(`RequisiÃ§Ã£o finalizada: ${req.customData}`);
    });
    
    next();
  };
}
```

**Plugin avanÃ§ado com operaÃ§Ãµes assÃ­ncronas:**

```typescript
export function pluginAssincrono(opcoes: Opcoes): RequestHandler {
  return async (req, res, next) => {
    try {
      // OperaÃ§Ãµes assÃ­ncronas
      const dados = await buscarAlgunsDados();
      req.pluginData = dados;
      next();
    } catch (error) {
      next(error);
    }
  };
}
```

## Melhores PrÃ¡ticas

### 1. A Ordem Importa

Aplique plugins na ordem correta para funcionalidade ideal:

```typescript
// âœ… Ordem correta
app.use(helmet());           // 1. SeguranÃ§a primeiro
app.use(cors());             // 2. CORS
app.use(bodyLimit());        // 3. Limites de parsing do body
app.use(compression());      // 4. CompressÃ£o
app.use(requestId());        // 5. Rastreamento de requisiÃ§Ã£o
app.use('/api', rateLimit()); // 6. Rate limiting
// ... suas rotas
```

### 2. ConfiguraÃ§Ã£o EspecÃ­fica do Ambiente

```typescript
const isProducao = process.env.NODE_ENV === 'production';

app.use(helmet({
  hsts: isProducao ? { maxAge: 31536000 } : false
}));

app.use(session({
  cookie: {
    secure: isProducao,
    sameSite: isProducao ? 'strict' : 'lax'
  }
}));
```

### 3. Ajuste de Performance

```typescript
// Comprimir apenas respostas grandes
app.use(compression({ 
  threshold: 2048  // MÃ­nimo de 2KB
}));

// Cachear health checks
app.use('/health', healthCheck({
  checks: { /* ... */ },
  cache: 30000  // Cache por 30 segundos
}));

// Otimizar rate limiting para alto trÃ¡fego
app.use(rateLimit({
  windowMs: 1000,  // Janelas de 1 segundo
  max: 10,         // Janelas menores, mais verificaÃ§Ãµes
}));
```

### 4. Tratamento de Erros

```typescript
import { circuitBreaker } from "azurajs/plugins";

app.use('/api/externo', circuitBreaker({
  failureThreshold: 5,
  timeout: 60000,
  onOpen: () => {
    // Alertar sistema de monitoramento
    servicoMonitoramento.alerta('Circuit breaker aberto');
  }
}));

// Handler de erro global
app.use((error, req, res, next) => {
  console.error(`[${req.id}] Erro:`, error);
  res.status(500).json({ 
    error: 'Erro interno do servidor',
    requestId: req.id 
  });
});
```

### 5. Checklist de SeguranÃ§a

Para deploys de produÃ§Ã£o, certifique-se de ter:

- âœ… Helmet para headers de seguranÃ§a
- âœ… CORS configurado corretamente
- âœ… Rate limiting em todos os endpoints pÃºblicos
- âœ… Limites de tamanho do body
- âœ… ProteÃ§Ã£o CSRF para operaÃ§Ãµes que mudam estado
- âœ… AutenticaÃ§Ã£o JWT ou sessÃ£o
- âœ… Timeouts de requisiÃ§Ã£o
- âœ… Endpoint de health check

## Impacto na Performance

### Resultados de Benchmark

- **CompressÃ£o**: 60-70% de reduÃ§Ã£o de largura de banda
- **ETag**: 90% de reduÃ§Ã£o para recursos cacheados
- **Request ID**: < 0.5ms de overhead
- **JWT Middleware**: < 2ms de overhead
- **Rate Limit**: < 1ms de overhead (em memÃ³ria)

### Uso de MemÃ³ria

- **Session Store**: ~50 bytes por sessÃ£o
- **SSE Manager**: ~1KB por cliente conectado
- **Rate Limit**: ~100 bytes por IP rastreado
- **Circuit Breaker**: ~100 bytes por instÃ¢ncia

## PrÃ³ximos Passos ğŸ“–

- [Melhores PrÃ¡ticas de SeguranÃ§a](/docs/pt/framework/avancado/seguranca)
- [Deploy em ProduÃ§Ã£o](/docs/pt/framework/avancado/producao)
- [OtimizaÃ§Ã£o de Performance](/docs/pt/framework/avancado/performance)
- [Desenvolvimento de Plugins Customizados](/docs/pt/framework/avancado/plugins-customizados)
